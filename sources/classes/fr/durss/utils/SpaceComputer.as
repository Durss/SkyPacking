package fr.durss.utils {	import fr.durss.utils.events.SpaceComputerEvent;	import com.nurun.utils.object.ObjectUtils;	import flash.display.BitmapData;	import flash.display.Stage;	import flash.events.Event;	import flash.events.EventDispatcher;	import flash.geom.Point;	import flash.geom.Rectangle;	/**	 * Returns the maximum number of 2x2 places, without overlaping, available in a bi-dimentionnal array.	 * 	 * @author  Francois	 */	public class SpaceComputer extends EventDispatcher {				private var _solutions:Array;		private var _matrix:Array;		private var _emptyMatrix:Array;		private var _i:Number;		private var _inc:Number;		private var _p:Array;		private var _sMax:Array;		private var _max:Number;		private var _len:Number;		private var _total:Number;		private var _stage:Stage;				private static const ITERATION_MAX:int = 200;						/* *********** *		 * CONSTRUCTOR *		 * *********** */		/**		 * Creates an instance of <code>SpaceComputer</code>.		 */		public function SpaceComputer(stage:Stage) {			_stage = stage;		}								/* ***************** *		 * GETTERS / SETTERS *		 * ***************** */		/**		 * Sets the matrix data.<br>		 * <br>		 * The parameter should be a bi-dimensional array whose cells should		 * contain true or false values.		 */		public function set matrix(matrix:Array):void {			var x:int, y:int, lenX:int, lenY:int;			_matrix			= ObjectUtils.clone(matrix) as Array;			_emptyMatrix	= ObjectUtils.clone(_matrix) as Array;			lenX	= (matrix[0] as Array).length;			lenY	= _emptyMatrix.length;			for(y = 0; y < lenY; ++y) {				for(x = 0; x < lenX; ++x) {					_emptyMatrix[y][x] = false;					if(_matrix[y][x] == undefined){						_matrix[y][x] = false;					}				}			}		}				/**		 * Gets an empty matrix pre-filled with false values.		 */		public function get emptyMatrix():Array { return ObjectUtils.clone(_emptyMatrix) as Array; }								/* ****** *		 * PUBLIC *		 * ****** */				/**		 * Gets a bitmapData representation of the data (for debug).		 * 		 * @param ratio		resize ratio. (ex: 2 = double sized)		 */		public function getBitmapDataRepresentation(ratio:int = 1):BitmapData {			var i:int, lenI:int, j:int, lenJ:int, bmd:BitmapData;			lenI	= _matrix.length;			bmd		= new BitmapData((_matrix[0] as Array).length * ratio, _matrix.length * ratio, true, 0);			for(i = 0; i < lenI; ++i) {				lenJ = (_matrix[i] as Array).length;				for(j = 0; j < lenJ; ++j) {					if(_matrix[i][j]) {						bmd.fillRect(new Rectangle(j * ratio, i * ratio, ratio, ratio), 0xFFCC0000);					}				}			}			return bmd;		}				/**		 * Gets a list of all the 2x2 available places.<br>		 * <br>		 * Two results returned by this method can overlap! It does not returns		 * the real number of solutions without overlaping.<br>		 * The returned value is an array of <code>Point</code> objects containing		 * the top left corner position of the available 2x2 places.		 * 		 * @return an array of <code>Point</code> objects.		 */		public function getAvailablePlaces():Array {			var x:int, y:int, lenX:int, lenY:int, ret:Array;			ret		= [];			lenX	= (_matrix[0] as Array).length;			lenY	= _matrix.length;			for(y = 0; y < lenY; ++y) {				for(x = 0; x < lenX; ++x) {					if(_matrix[y][x] === true) {						try {							if(_matrix[y][x+1] === true && _matrix[y+1][x] === true && _matrix[y+1][x+1] === true){								ret.push(new Point(x, y));							}						}catch(e:Error) { }					}				}			}			return ret;		}				/**		 * Compute the maximum number of 2x2 available places WITHOUT overlaping.<br>		 * <br>		 * When the solution is found, the classs fires an <code>SpaceComputerEvent.SEARCH_COMPLETE</code> event.		 */		public function getMaximumSolutions():void {			_solutions	= getAvailablePlaces();			_len		= _solutions.length;			_p			= [];			_inc		= 0;			_sMax		= [];			_max		= 0;			_total		= 1;			for(_i = 0; _i < _len; ++_i) {				_p[_i] = 0;				_total *= (_i+1);			}			_i = 1;			if(_len < 2) {				dispatchEvent(new SpaceComputerEvent(SpaceComputerEvent.SEARCH_START, _solutions));				dispatchEvent(new SpaceComputerEvent(SpaceComputerEvent.SEARCH_COMPLETE, _solutions));			}else{				iterate();				if(!_stage.hasEventListener(Event.ENTER_FRAME)) {					_stage.addEventListener(Event.ENTER_FRAME, iterate);				}				dispatchEvent(new SpaceComputerEvent(SpaceComputerEvent.SEARCH_START, _sMax));			}		}								/* ******* *		 * PRIVATE *		 * ******* */				/**		 * Public function make a new search iteration.		 */		private function iterate(e:Event = null):void {			var i:int, j:int, swap:Point, s:Array, tot:int;			i = 0;			while(_i<_len && i < ITERATION_MAX) {				if (_p[_i] < _i) {					if(_i % 2 == 1) {						j = _p[_i];					}else{						j = 0;					}					swap			= _solutions[j];					_solutions[j]	= _solutions[_i];					_solutions[_i]	= swap;					_p[_i] ++;					_i = 1;					s = checkNumber();					tot = s.length;					if(tot > _max){						_max = tot;						_sMax = s;					}					_inc ++;				} else {					_p[_i] = 0;					_i ++;				}				i ++;			}			if(_i >= _len) {				_stage.removeEventListener(Event.ENTER_FRAME, iterate);				dispatchEvent(new SpaceComputerEvent(SpaceComputerEvent.SEARCH_COMPLETE, _sMax));			}else{				dispatchEvent(new SpaceComputerEvent(SpaceComputerEvent.SEARCH_PROGRESS, _sMax, _inc/_total));			}		}				/**		 * Checks the number of solutions of the current result.		 */		private function checkNumber():Array {			var i:int, len:int, pos:Point, ret:Array, copy:Array;			copy	= ObjectUtils.clone(_emptyMatrix) as Array;			ret		= [];			len		= _len;			for(i = 0; i < len; ++i) {				pos = _solutions[i] as Point;				if(copy[pos.y][pos.x] === false && copy[pos.y][pos.x+1] === false && copy[pos.y+1][pos.x] === false && copy[pos.y+1][pos.x+1] === false) {					copy[pos.y][pos.x]			= true;					copy[pos.y][pos.x + 1]		= true;					copy[pos.y + 1][pos.x]		= true;					copy[pos.y + 1][pos.x + 1]	= true;					ret.push(new Point(pos.x, pos.y));				}			}			return ret;		}	}}