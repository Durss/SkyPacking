package fr.durss.skywar.skypacking.views {	import fr.durss.skywar.skypacking.data.Model;	import fr.durss.skywar.skypacking.graphics.DottedRectangle;	import fr.durss.utils.SpaceComputer;	import fr.durss.utils.events.SpaceComputerEvent;	import gs.TweenLite;	import com.nurun.components.text.CssTextField;	import com.nurun.structure.mvc.model.events.IModelEvent;	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.geom.Point;	import flash.geom.Rectangle;	import flash.ui.Mouse;	/**	 * Displays the input views.<br>	 * <br>	 * This view provides a way to place and remove solutions manually.	 * 	 * @author  Francois	 */	public class Input extends AbstractSPView {		private var _resultTxt:CssTextField;		private var _places:Array;		private var _selection:DottedRectangle;		private var _bmd:BitmapData;		private var _matrix:Array;		private var _computer:SpaceComputer;		private var _solutions:int;								/* *********** *		 * CONSTRUCTOR *		 * *********** */		/**		 * Creates an instance of <code>Input</code>.<br>		 */		public function Input() {			super();		}						/* ***************** *		 * GETTERS / SETTERS *		 * ***************** */		/* ****** *		 * PUBLIC *		 * ****** */		override public function update(e:IModelEvent):void {			var model:Model = e.model as Model;						if(_computer == null) {				_computer	= model.computer;				_matrix		= _computer.emptyMatrix;				_computer.addEventListener(SpaceComputerEvent.SEARCH_START, newGridHandler);			}						if(model.stateIndex == 1) {				_places = model.computer.getAvailablePlaces();				updateResults();				open();			}else{				close();			}		}								/* ******* *		 * PRIVATE *		 * ******* */		/**		 * Initialize the class.<br>		 */		override protected function initialize(e:Event):void {			super.initialize(e);						_bmd		= new BitmapData(COLS * CELL_SIZE, ROWS * CELL_SIZE, true, 0x0ffffff);			_selection	= addChild(new DottedRectangle(CELL_SIZE * 2 - 6, CELL_SIZE * 2 - 6)) as DottedRectangle;			_resultTxt	= addChild(new CssTextField("windowLabel")) as CssTextField;						_selection.visible = false;			addChildAt(new Bitmap(_bmd), 0);						addEventListener(MouseEvent.MOUSE_DOWN,	clickHandler);			stage.addEventListener(MouseEvent.MOUSE_MOVE,	mouseMoveHandler);						computePositions();		}				/**		 * Resize and replace the elements.<br>		 */		private function computePositions():void {			_resultTxt.x= Math.round((WIDTH - (x*2) - _resultTxt.width) * .5);			_resultTxt.y= Math.round(_bmd.height + 3);		}				/**		 * Updates the results.		 */		private function updateResults():void {			_resultTxt.setText(_solutions + " places de 2x2 remplies.");			mouseMoveHandler();			computePositions();		}										//__________________________________________________________ UTILS		/**		 * Gets the mouse's equivalent position in rows and cols.<br>		 * <br>		 * For example if the mouse is over the first cell, it will return		 * a <code>Point</code> instance with 0 and 0 as <code>x</code> and		 * <code>y</code> values.		 * 		 * @return a <code>Point</code> object or null if mouse is out of bounds.		 */		private function getMousePos():Point {			if(mouseX < 0 || mouseY < 0 || mouseX > COLS * CELL_SIZE - 1 || mouseY > ROWS * CELL_SIZE - 1) {				return null;			}else{				return new Point(Math.floor(mouseX / CELL_SIZE), Math.floor(mouseY / CELL_SIZE));			}		}				/**		 * Checks if a 2x2 place is available under the given coordinates.		 */		private function checkIfAvailable(x:int, y:int, checkMatrix:Boolean = true):Boolean {			var i:int, len:int, pos:Point;			len = _places.length;			for(i = 0; i < len; ++i) {				pos = _places[i];				if(pos.x == x && pos.y == y) {					if(!_matrix[y][x] && !_matrix[y][x+1] && !_matrix[y+1][x] && !_matrix[y+1][x+1] && checkMatrix){						return true;					}					if(!checkMatrix) return true;				}			}			return false;		}				/**		 * Checks if a specific coordinate is completly filled or empty.<br>		 * <br>		 * This method takes the given corrdinates and checks if the left, bottom		 * and bottom left places are all filled or all empty.		 * 		 * @return if it's solid place.		 */		public function isSolidPlace(x:int, y:int):Boolean {			var solid:int = _matrix[y][x]? 1 : 0;			solid += _matrix[y][x+1]? 1 : 0;			solid += _matrix[y+1][x]? 1 : 0;			solid += _matrix[y+1][x+1]? 1 : 0;			return solid == 0 || solid == 4;		}										//__________________________________________________________ MOUSE EVENTS				/**		 * Called on mouse move.		 * 		 * @param e	event object		 */		private function mouseMoveHandler(e:MouseEvent = null):void {			if(!_opened) return;			var pos:Point= getMousePos();			if(pos == null) {				_selection.visible = false;				Mouse.show();			}else{				if(pos.x >= COLS - 2) pos.x = COLS - 2;				if(pos.y >= ROWS - 2) pos.y = ROWS - 2;				_selection.x	= pos.x * CELL_SIZE + 3;				_selection.y	= pos.y * CELL_SIZE + 3;				_selection.visible = true;								if(checkIfAvailable(pos.x, pos.y)){					TweenLite.to(_selection, .5, {tint:0xffffff});				}else if(isSolidPlace(pos.x, pos.y) && checkIfAvailable(pos.x, pos.y, false)){					TweenLite.to(_selection, .5, {tint:0});				}else{					TweenLite.to(_selection, .5, {removeTint:true});				}								Mouse.hide();			}		}		/**		 * Called when mouse is pressed.		 * 		 * @param e	event object		 */		private function clickHandler(e:MouseEvent):void {			var pos:Point= getMousePos();			var x:int = pos.x;			var y:int = pos.y;			if(checkIfAvailable(x, y, false)){				if(!isSolidPlace(x, y)) return;								_matrix[y][x] = _matrix[y][x+1] = _matrix[y+1][x] = _matrix[y+1][x+1] = !_matrix[y][x];				_solutions += _matrix[y][x]? 1 : -1;				_bmd.fillRect(new Rectangle(x * CELL_SIZE + 1, y * CELL_SIZE + 1, CELL_SIZE * 2 - 2, CELL_SIZE * 2 - 2), (_matrix[y][x])? 0x88FFFFFF : 0x00ffffff);			}			updateResults();		}								//__________________________________________________________ GRID EVENTS				/**		 * Called when the grid is modified.		 */		private function newGridHandler(e:SpaceComputerEvent):void {			_solutions	= 0;			_matrix		= _computer.emptyMatrix;			_bmd.fillRect(_bmd.rect, 0x00ffffff);		}			}}