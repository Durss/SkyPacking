package fr.durss.skywar.skypacking.views {	import flash.net.URLRequest;	import flash.net.navigateToURL;	import fr.durss.components.ui.tooltip.ToolTipAlign;	import fr.durss.components.ui.tooltip.SimpleToolTip;	import fr.durss.skywar.skypacking.components.SubmitButton;	import fr.durss.skywar.skypacking.controller.FrontController;	import fr.durss.skywar.skypacking.data.Model;	import fr.durss.skywar.skypacking.graphics.CloseDistortBt;	import fr.durss.skywar.skypacking.graphics.DottedRectangle;	import fr.durss.skywar.skypacking.graphics.DragBar;	import gs.TweenLite;	import com.jidd.display.DashedLine;	import com.nurun.components.button.BaseButton;	import com.nurun.components.button.GraphicButton;	import com.nurun.components.button.visitors.FrameVisitor;	import com.nurun.structure.mvc.model.events.IModelEvent;	import com.nurun.utils.object.ObjectUtils;	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.DisplayObject;	import flash.display.MovieClip;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.geom.PerspectiveProjection;	import flash.geom.Point;	import flash.ui.Mouse;	/**	 * Displays the grid that can be filled by clicking on cells.<br>	 * <br>	 * Fires an <code>Event.CHANGE</code> event when a new result is available.<br>	 * Use <code>totalPlaces</code> getter to get the total available results.	 * 	 * @author  Francois	 */	public class Grid extends AbstractSPView {				private var _square:DottedRectangle;		private var _matrix:Array;		private var _bmdFill:BitmapData;		private var _lastPos:Point;		private var _startCellType:Boolean;		private var _pressed:Boolean;		private var _freeze:Boolean;		private var _clearBt:SubmitButton;		private var _copyBt:SubmitButton;		private var _emptyMatrix:Object;		private var _gridCtn:Sprite;		private var _dragBar:GraphicButton;		private var _closeBt:GraphicButton;		private var _bitmap:Bitmap;		private var _tooltip:SimpleToolTip;						/* *********** *		 * CONSTRUCTOR *		 * *********** */		/**		 * Creates an instance of <code>GridView</code>.		 */		public function Grid() {			super();		}						/* ***************** *		 * GETTERS / SETTERS *		 * ***************** */		override public function get height():Number { return ROWS * CELL_SIZE; }								/* ****** *		 * PUBLIC *		 * ****** */		override public function update(e:IModelEvent):void {			var model:Model = e.model as Model;			_freeze =  model.stateIndex != 0 && model.stateIndex != 2;			_emptyMatrix = ObjectUtils.clone(model.computer.emptyMatrix) as Array;			if(model.stateIndex < 3) {				open();				if(model.copyMode) {					_clearBt.visible = false;					_copyBt.visible = false;					TweenLite.to(_dragBar, .5, {autoAlpha:1});					TweenLite.to(_closeBt, .5, {autoAlpha:1});					TweenLite.to(_bitmap, .5, {autoAlpha:.5});					TweenLite.to(_gridCtn, .5, {tint:0, overwrite:0});				}else {					if(model.stateIndex == 0) {						TweenLite.to(_clearBt, .5, {autoAlpha:1, blurFilter:{blurX:0, blurY:0, remove:true}});						TweenLite.to(_copyBt, .5, {autoAlpha:1, blurFilter:{blurX:0, blurY:0, remove:true}});					}else{						TweenLite.to(_clearBt, .5, {autoAlpha:0, blurFilter:{blurX:20, blurY:20}});						TweenLite.to(_copyBt, .5, {autoAlpha:0, blurFilter:{blurX:20, blurY:20}});					}					_clearBt.visible = true;					_copyBt.visible = true;					TweenLite.to(_bitmap, .5, {autoAlpha:1});					TweenLite.to(_dragBar, .5, {autoAlpha:0});					TweenLite.to(_closeBt, .5, {autoAlpha:0});					TweenLite.to(_gridCtn, .5, {removeTint:true, overwrite:0});				}			}else{				close();			}		}								/* ******* *		 * PRIVATE *		 * ******* */		/**		 * Initializes the class.		 */		override protected function initialize(e:Event):void {			super.initialize(e);			_gridCtn = addChild(new Sprite()) as Sprite;						_dragBar = _gridCtn.addChild(new GraphicButton(new DragBar())) as GraphicButton;			var fv:FrameVisitor = new FrameVisitor();			fv.addTarget(_dragBar.background as MovieClip);			_dragBar.accept(fv);						_closeBt = _gridCtn.addChild(new GraphicButton(new CloseDistortBt())) as GraphicButton;			fv = new FrameVisitor();			fv.addTarget(_closeBt.background as MovieClip);			_closeBt.accept(fv);						//Draw grid			var x:int, y:int, line:DashedLine;			for(x = 0; x <= COLS; ++x) {				line	= _gridCtn.addChild(new DashedLine(2, 2, ROWS * CELL_SIZE, 1, "ED9D00")) as DashedLine;				line.x	= x * CELL_SIZE;				line.rotation = 90;			}			for(y = 0; y <= ROWS; ++y) {				line	= _gridCtn.addChild(new DashedLine(2, 2, COLS * CELL_SIZE, 1, "ED9D00")) as DashedLine;				line.y	= y * CELL_SIZE;			}						_matrix	= new Array(ROWS);			for(y = 0; y < ROWS; ++y) {				_matrix[y] = new Array(COLS);				for(x = 0; x < COLS; ++x) {					_matrix[y][x] = false;				}			}						_bmdFill			= new BitmapData(COLS, ROWS, true, 0);			_bitmap				= _gridCtn.addChild(new Bitmap(_bmdFill)) as Bitmap;			_square				= _gridCtn.addChild(new DottedRectangle(CELL_SIZE - 6, CELL_SIZE - 6)) as DottedRectangle;			_copyBt				= addChild(new SubmitButton("Décalquer")) as SubmitButton;			_clearBt			= addChild(new SubmitButton("Effacer")) as SubmitButton;			_tooltip			= addChild(new SimpleToolTip()) as SimpleToolTip;			_square.visible		= false;			_dragBar.visible	= false;			var isAir:Boolean	= false;			/*FDT_IGNORE*/			CONFIG::Air {			/*FDT_IGNORE*/				isAir = true;			/*FDT_IGNORE*/			}			/*FDT_IGNORE*/			if(!isAir) {				_copyBt.enabled		= false;				_copyBt.mouseEnabled= true;				_copyBt.addEventListener(MouseEvent.ROLL_OVER,	overCopyBtHandler);				_copyBt.addEventListener(MouseEvent.ROLL_OUT,	outCopyBtHandler);			}						_gridCtn.graphics.beginFill(0xED9D00, .2);			_gridCtn.graphics.drawRect(0, 0, COLS * CELL_SIZE, ROWS * CELL_SIZE);						addEventListener(MouseEvent.MOUSE_DOWN,			mouseDownHandler);			stage.addEventListener(MouseEvent.MOUSE_UP,		mouseUpHandler);			stage.addEventListener(MouseEvent.MOUSE_MOVE,	mouseMoveHandler);			_clearBt.addEventListener(MouseEvent.CLICK,		clickClearBtHandler);			_copyBt.addEventListener(MouseEvent.CLICK,		clickCopyBtHandler);			_closeBt.addEventListener(MouseEvent.CLICK,		clickCopyBtHandler);						computePositions();						setMatrix();		}		/**		 * Resize and replace the elements		 */		private function computePositions():void {			var availWidth:int	= WIDTH - _clearBt.width - _copyBt.width;			_clearBt.x			= availWidth / 3;			_clearBt.y			= Math.round(_gridCtn.height + 1);			_copyBt.x			= WIDTH - _copyBt.width - availWidth / 3;			_copyBt.y			= _clearBt.y;			_dragBar.height		= CELL_SIZE;			_dragBar.width		= CELL_SIZE * COLS;			_dragBar.x			= -1;			_dragBar.y			= -_dragBar.height+1;			_closeBt.x			= CELL_SIZE * COLS;			_closeBt.height		= CELL_SIZE;			_closeBt.width		= CELL_SIZE;			_closeBt.visible	= false;			_bitmap.scaleX		= _bitmap.scaleY = CELL_SIZE;		}		/**		 * Computes and displays the maximum available places.		 */		private function setMatrix():void {			FrontController.getInstance().registerMatrix(_matrix);		}				/**		 * Fill a cell.		 * 		 * @param x		X index of the cell to fill		 * @param y		Y index of the cell to fill		 * 		 * @return the new cell state.		 */		private function fillCell(x:int, y:int, ignoreStart:Boolean = false):Boolean {			var value:Boolean	= _matrix[y][x];			if(!ignoreStart){				_matrix[y][x]	= _startCellType;				_bmdFill.setPixel32(x, y, _startCellType? 0xFFED9D00 : 0);			}else{				_matrix[y][x]	= !value;				_bmdFill.setPixel32(x, y, !value? 0xFFED9D00 : 0);			}			return !value;		}		/**		 * Gets the mouse's equivalent position in rows and cols.<br>		 * <br>		 * For example if the mouse is over the first cell, it will return		 * a <code>Point</code> instance with 0 and 0 as <code>x</code> and		 * <code>y</code> values.		 * 		 * @return a <code>Point</code> object or null if mouse is out of bounds.		 */		private function getMousePos():Point {			var target:DisplayObject = _gridCtn;			var px:int = target.mouseX;			var py:int = target.mouseY;			var minX:int = 0;//-target.width * .5;			var minY:int = 0;//-target.height * .5;			if(px < minX || py < minY || px > COLS * CELL_SIZE - 1 + minX || py > ROWS * CELL_SIZE - 1 + minY) {				return null;			}else{				return new Point(Math.floor((px-minX) / CELL_SIZE), Math.floor((py-minY) / CELL_SIZE));			}		}										//__________________________________________________________ MOUSE EVENTS				/**		 * Called on mouse move.		 * 		 * @param e	event object		 */		private function mouseMoveHandler(e:MouseEvent):void {			if(_freeze) return;			var pos:Point= getMousePos();			if(pos == null) {				_square.visible = false;				Mouse.show();			}else{				_square.x	= pos.x * CELL_SIZE + 3;				_square.y	= pos.y * CELL_SIZE + 3;				_square.visible = true;								//If the mouse button is pressed, change the cell's state.				if(_pressed && (_lastPos == null || pos.x != _lastPos.x || pos.y != _lastPos.y)) {					fillCell(pos.x, pos.y);					_lastPos = pos;					setMatrix();				}				if(!_dragBar.visible){					Mouse.hide();				}			}		}				/**		 * Called when mouse is released.		 * 		 * @param e	event object		 */		private function mouseUpHandler(e:MouseEvent):void {			_pressed = false;			stopDrag();		}				/**		 * Called when mouse is pressed.		 * 		 * @param e	event object		 */		private function mouseDownHandler(e:MouseEvent):void {			if(e.target == _dragBar) _gridCtn.startDrag();			if(e.target is BaseButton || e.target is GraphicButton || e.target is Grid) return;			_pressed		= true;			_lastPos		= getMousePos();			_startCellType	= fillCell(_lastPos.x, _lastPos.y, true);			setMatrix();		}				/**		 * Called when clear button is clicked.		 */		private function clickClearBtHandler(e:MouseEvent):void {			_bmdFill.fillRect(_bmdFill.rect, 0);			_matrix = ObjectUtils.clone(_emptyMatrix) as Array;			setMatrix();		}				/**		 * Called when distort button is clicked.		 */		private function clickCopyBtHandler(e:MouseEvent):void {			if(!_copyBt.enabled){				navigateToURL(new URLRequest("http://skywar.free.fr/apps/skypacking/SkyPacking.air"));				return;			}			FrontController.getInstance().copyMode = e.currentTarget == _copyBt;			if(e.currentTarget == _copyBt) {				var perspective:PerspectiveProjection = new PerspectiveProjection();				perspective.fieldOfView = 1;				_gridCtn.parent.transform.perspectiveProjection = perspective;				TweenLite.to(_gridCtn, .5, {rotationX:-49, rotationY:35, rotationZ:28, scaleX:2.1, scaleY:2.1, overwrite:0});			}else{				TweenLite.to(_gridCtn, .5, {x:0, y:0, rotationX:0, rotationY:0, rotationZ:0, scaleX:1, scaleY:1, overwrite:0, onComplete:clearMatrix3D});			}		}				/**		 * Called when copy button is rolled over.		 */		private function outCopyBtHandler(e:MouseEvent):void {			_tooltip.close();		}		/**		 * Called when copy button is rolled out.		 */		private function overCopyBtHandler(e:MouseEvent):void {			_tooltip.width = 225;			_tooltip.open("Cette option n'est disponible qu'avec la <b>version AIR</b>. Donc soit tu te galère avec la grille actuelle, soit tu révolutionne ta vie en installant la version AIR =D<br><br><b>Clique pour télécharger la version AIR.</b>", "toolTipContent", ToolTipAlign.TOP_LEFT);		}		/**		 * Removes the transformation Matrix to kill the cacheAsBitmap mode.		 */		private function clearMatrix3D():void {			_gridCtn.transform.matrix3D = null;		}	}}